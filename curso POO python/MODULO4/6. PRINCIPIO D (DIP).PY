#DIP
#DEPENDENCY INVERSION PRINCIPLE
#Las clases de alto nivel no deben depender de clases de bajo nivel. Ambas deben depender de abstracciones.
#El cÃ³digo debe depender de interfaces o abstracciones, no de implementaciones concretas.
# Esto hace que el sistema sea mÃ¡s flexible, desacoplado y fÃ¡cil de cambiar o extender.

# AbstracciÃ³n
class Motor:
    def encender(self):
        pass

# Implementaciones concretas
class MotorGasolina(Motor):
    def encender(self):
        print("â›½ Motor de gasolina encendido.")

class MotorElectrico(Motor):
    def encender(self):
        print("ðŸ”‹ Motor elÃ©ctrico encendido.")

# Clase de alto nivel que depende de la abstracciÃ³n, no de una implementaciÃ³n
class Auto:
    def __init__(self, motor: Motor):
        self.motor = motor  # âœ… InyecciÃ³n de dependencia

    def arrancar(self):
        self.motor.encender()

# --- USO VISUAL ---
print("ðŸš™ Auto con motor de gasolina:")
auto1 = Auto(MotorGasolina())
auto1.arrancar()

print("\nðŸš— Auto con motor elÃ©ctrico:")
auto2 = Auto(MotorElectrico())
auto2.arrancar()
#âœ… Â¿Por quÃ© este ejemplo cumple DIP?
#Auto depende de la interfaz Motor, no de una clase concreta.
# Puedes agregar nuevos tipos de motores sin tocar la clase Auto.
# Mayor flexibilidad, mantenimiento y extensiÃ³n del cÃ³digo.

